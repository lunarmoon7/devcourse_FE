# 브라우저의 동작 원리
- 통신 
	- 서버와의 통신을 의미.
		1. 브라우저가 서버에 요청을 보낸다.
		2. 서버는 요청에 따라 특정 값을 응답한다.
		3. 요청은 한번에 하나씩 또는  씩 가능하다.
	![[스크린샷 2023-09-20 오후 3.14.03.png]]
- 렌더링
	- DOM이라는 객체를 화면에 그리는 것을 의미한다.
		+) DOM은 통신을 통해서 받은 HTML을 브라우저가 읽어서 생성된다.
	- DOM은 트리구조로 이루어져 있다.
		![[스크린샷 2023-09-20 오후 3.16.37.png]]
- 스크립트 실행
	- JavaScript를 실행시키는 것을 의미.
	- 브라우저가 script 태그를 통해 JavaScript 태그를 읽으면 바로 실행된다.
	- 이를 통해 UI에 이벤트를 등록할 수 있고, 다크모드 설정 등 동적인 화면 구성이 가능하다.

> **프론트엔드 개발자의 핵심 역량은?**
1. 커뮤니케이션
2. UI
3. 네트워크
4. 보안
5. 브라우저
6. 디자인
> **프론트엔드 개발자가 하지 말아야 할 것은?**
1. CS 무시
2. CSS 안하기(대충 공부하기)
3. 코더가 되는 것(=라이브러리나 프레임워크의 기능을 가져다 쓰기만 하는 것)
***
# 변수, 상수, 자료형, 메모리
## 변수
수학적 변수와는 의미가 다르다. → ✅ **직접 메모리에 할당한 값을 의미한다.**
변수를 선언하기 위해서는 예약어가 필요하다.
- `var` : ES6 이전에 사용되던 예약어 → **권장하지 않는다.**
	- #숙제 [[호이스팅]]이라는 JS의 동작때문에 권장하지 않는다.
- `let` : ES6 이후에 사용 가능 → **권장**
## 상수
상수란, 변하지 않는 수를 의미한다. → **한 번 값을 설정하면 변경이 불가능하다.**
- `const` 
## 자료형
- `Number` : 정수, 실수
	- `NaN` : Not a Number → 숫자가 아님을 의미 **but**, `Number` 타입에 속한다.
	- `Infinity`
- `String` : 문자열, `“”`, `''`, `` 으로 표시된다.
- `Boolean` : true, false
- `Object` : Key-Value으로 이루어진 타입(여러 개의 Key 존재가능, Key는 반드시 문자열)
- `Array` : 여러 값을 가질 수 있는 타입 → Key는 가지지 않고 Index로 값을 찾을 수 있다.
- `Function` : 함수를 의미, 함수도 변수에 담을 수 있다.
- `undefined` : 변수 혹은 상수가 선언되었지만 아무런 값도 대입되지 않았음을 의미
- `null` : null이라는 값을 설정했음을 의미(해당 변수가 비었다는 것을 사용자가 의도적으로 표시할 때 사용됨)
## 메모리
메모리 공간은 한정되어 있다 → 변수, 상수를 선언하면 그 만큼 메모리 공간은 줄어든다.
#### 과정
- 할당
- 사용
- 해제
	- 사용자가 직접 해제하지 않는다.
	- `Garbage Collector` : 가비지 컬렉션이라는 자동 메모리 관리 알고리즘을 통해 만들어진 객체로 사용하지 않는 메모리를 해제하는 역할을 수행한다.
#### 메모리 심화
- 선언한 변수나 상수는 값을 바라보는게 아닌, 메모리 주소를 바라본다.
- 기존 변수를 조작하면? → 새로운 메모리 주소를 할당받고 그 곳에 값을 설정한다. 
	- **why?** JS에서 [[원시타입]]은 변경이 불가능하기 때문.
- 따라서, 원시타입의 값이 변경될 때는 항상 메모리가 새로 할당된다.
*** 
- JS 엔진은 가상 머신으로 구성되어 있다. 가상 머신에는 메모리 모델이 구현되어 있다.
	- `heap 영역` : 참조타입이 들어감
	- `call stack 영역` :  원시타입이 들어감
	![[스크린샷 2023-09-20 오후 3.48.15.png]]
	- **배열은 Object타입 이므로** [[참조 타입]]으로 분류된다.
		- 배열을 선언하면 `heap`에 배열 영역이 생성되는데,  배열 변수는 `call stack`에 생성된다.
		- 배열 변수는 `heap`에서 생성된 배열의 메모리 주소를 참조한다.
		- `heap`영역 메모리는 동적으로 크기가 변할 수 있다. → 배열에 값을 추가하면 `heap`영역에 할당이 된다.
		- 배열을 `const`로 선언했는데 `push`가 동작한다?
			- `call stack`에 할당된 메모리를 변경하는 것이 아닌, `heap` 메모리를 변경하는 것이기 때문.
- 현대적인 브라우저의 garbage collector는 `Mark and Sweep Algorithm`을 통해 메모리를 정리한다.
	- `Mark and Sweep Algorithm` : 닿을 수 없는 주소를 더 이상 필요없는 주소로 정의하고 지우는 알고리즘
	 ![[스크린샷 2023-09-20 오후 3.53.45.png]]

> 메모리가 지워지는 것은 **참조**가 중요하다.
> Closure가 가능한 이유도 **참조** 덕분이다.

> **배열은 Object타입이다?**
> 배열(Array)은 **객체(Object)의 일종**이다. 즉, **배열은 객체이며 특정한 종류의 객체로서 정의**된다.
> 배열은 특별한 형태의 객체로서, **인덱스를 통해 요소에 접근**할 수 있도록 해주는 등의 추가적인 기능을 제공한다.

***
# 표현식과 연산자
## 표현식
표현식이란, 어떠한 결과 값으로 평가되는 식이다. 즉, 결과가 계산되는 식을 의미한다.
숫자, 문자열, 논리값 같은 원시 값을 포함하여 변수, 상수, 함수 호출 등으로 조합할 수 있다.
```js
const a = 10 + 32;
const b = a - 20;
const c = "hello" + 3;
const d = true + false + true;
```
## 연산자
- **할당 연산자**
	- 오른쪽 표현식을 왼쪽 피연산자 값에 할당하는 연산자
	- 등호(=)를 사용하며 다른 연산자와 같이 사용하여 복합 할당 연산자로 이용할 수 있다.
- **비교 연산자**
	- 좌측 피연산자와 우측 피연산자를 비교하는 연산자
	- true, false를 반환한다.
- **산술 연산자**
	- 덧셈, 뺄셈, 곱셈, 나눗셈을 하는 연산자
	- Number를 반환한다
- **비트 연산자**
	- 비트를 직접 조작하는 연산자
	- 이진법으로 나타냈을 때의 비트를 조작한다.
- **논리 연산자**
	- Boolean을 통해 참과 거짓을 검증하는 연산자
- **삼항 연산자**
	- 조건에 따라 값을 선택하는 연산자
	- `조건 ? 참 : 거짓`형태를 가진다.
- **관계 연산자**
	- 객체에 속성이 있는지 확인하기 위한 연산자
- **typeof**
	- 피연산자의 타입을 반환하는 연산자
	- 문자열로 반환된다.
***
# 흐름제어
- Control Flow : 조건이나 반복을 통해 상태를 제어하는 것
	- `Goto, If / Then / Else, Switch / Case, For / While`
- Data Flow : 함수형 프로그래밍 방식으로 구현가능
	- `Stateless, Recursion, Pipe`
## 조건문
특정 조건이 맞을 때만 실행되는 문법.
- **if** : 괄호 안 조건식이 참인 경우 실행되는 문법
	- else if, else도 같이 사용 가능
	- false뿐만 아니라 `undefined, null, 0, NaN, "”`도 거짓으로 판단한다.
- **switch** : 괄호 안 값에 따라 분기되는 문법
	- case, default와 함께 쓰인다.
	- case의 마지막에 break를 적어줘야 한다.
## 반복문
반복적인 작업을 지시하는 문법
- **for** : 가장 기초적인 반복문
	- 초기문, 조건문, 증감문으로 구성
	- 조건문의 결과가 거짓이라면 반복이 종료
- **while** : 괄호안 조건이 거짓이 될 때까지 반복
- **do-while** : 먼저 진입 후 로직을 실행한 다음 조건을 검사(1번은 무조건 실행)
***
# 배열과 객체
## 배열
연관된 데이터를 연속적인 형태로 저장하는 복합 타입이다.
배열에 포함된 원소는 순서대로 번호(`index`)가 붙는다.
> **배열을 직접 할당하지 않고 [1,2,3,4,5]로 초기화 하고 싶다면?** → `Array.from()`

```js
const arr = Array.from(Array(5), function (v, k) {
	return k + 1;
})

console.log(arr); // [1, 2, 3, 4, 5]
```
- `Array.from(param1, param2)`
	- `param1` : 초기화할 배열(=배열의 크기)
	- `param2` : 배열을 초기화할 함수
		- `function(v, k) { return ...}` : `param2`는 이 형태를 가져야 한다. `v`는 값, `k`는 인덱스
> **배열의 값들을 특정 문자를 기준으로 문자열로 표현하고 싶다면?** → `Array.join()`
```js
const arr = [1, 2, 3, 4, 5, 6];
console.log(arr.join(", ")); // 1, 2, 3, 4, 5, 6
```
- `Array.join(param1)`
	- `param1` : 원하는 특정 문자 → 문자열이어야 한다.
> **배열을 거꾸로 변경하고 싶다면?** → `Array.reverse()`

```js
const arr = [1, 2, 3];
console.log(arr.reverse()); // [3, 2, 1]
```
> **두 배열을 합치고 싶다면?** → `Array.concat()`
```js
const arr1 = [1,2,3,4,5];
const arr2 = [6,7,8,9,10];

console.log(arr1.concat(arr2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
> 맨앞에 요소를 제거하기, 추가하기 → `shift(), unshift()`
```js
const arr = [1, 2, 3, 4, 5,];

arr.shift();
arr.shift();
console.log(arr); // [3, 4, 5]

arr.unshift(10);
console.log(arr); // [10, 3, 4, 5]
```
## 객체
객체는 여러 값을 Key-Value 형태로 결합시킨 복합 타입이다.
> 객체에 값을 추가하고 싶다면?
```js
const obj = { name : '휘식', age: '24'};
obj.job = 'Frontend Developer';
obj['hobby'] = 'do code';
```
> 값을 삭제하고 싶다면?
```js
const obj = { name : '휘식', age: '24'};
delete obj.age;
```
> Key, Value 집합 구하기 → `Object.keys(), Object.values()`
```js
const obj = { name : '휘식', age: '24'};
Object.keys(obj); // ['name', 'age'];
Object.values(obj); // ['휘식', '24'];
```
***
# 스코프와 클로저
- ==**스코프**==
	- 유효 범위라고도 하며, 변수가 어느 범위까지 참조되는 지를 뜻한다.
		![[스크린샷 2023-09-20 오후 5.38.13.png]]
> var를 사용하면 개발자가 예상치 못한 오류가 생길 수 있다.
>`var`는 **함수 수준**의 스코프를 가진다.
>`const, let`은 **블록 수준**의 스코프를 가진다.
- ==**클로저**==
	- 함수가 선언된 환경의 스코프를 기억하여 함수가 스코프 밖에서 실행될 때에도 기억한 스코프에 접근할 수 있게 만드는 ![[스크린샷 2023-09-20 오후 5.43.06.png]]문법![[스크린샷 2023-09-20 오후 5.43.06.png]]
- ==**은닉화**==
	- 클로저를 이용하여 내부 변수와 함수를 숨길 수 있다.![[스크린샷 2023-09-20 오후 5.43.56.png]]
		- `Counter()`내의 `privateCounter`와 `changeBy`는 외부에서 접근이 불가한 것을 알 수 있다.
			- 반환된 함수로만 접근이 가능한 것을 볼 수 있다. → 클로저를 이용하여 내부 변수와 함수를 숨길 수 있다.
>클로저를 잘 알아야 하는 이유는 유용하게 사용하기보단, ==알기 힘든 버그를 잘 수정하기 위해서==이다.

> **다음 코드의 결과는 어떻게 될까?**
> ![[스크린샷 2023-09-20 오후 5.47.47.png]]
> **why?** → `setTimeout`의 대기시간이 끝나 `callback` 함수가 실행된 시점에는 루프가 종료되어 `i`가 `5`가 되었기 때문이다.
> **해결방법**
> (1) **IIFE** 이용
> ![[스크린샷 2023-09-20 오후 5.49.59.png]]
> (2) **let** 사용![[스크린샷 2023-09-20 오후 5.50.56.png]]
> 